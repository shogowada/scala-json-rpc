# Bidirectional JSON-RPC between Scals JS and Scala JVM over WebSocket

When your application is both server and client, incoming JSON messages can be either request or response, so you need to make sure requests are received by server and responses are received by client.

You can write something like below to make sure the JSON is handled appropriately.

```scala
val wasJsonRpcResponse: Boolean = jsonRpcClient.receive(json)
if (!wasJsonRpcResponse) {
  jsonRpcServer.receive(json).onComplete {
    case Success(Some(responseJson: String)) => jsonRpcClient.send(responseJson)
    case _ =>
  }
}
```

But it is tedious and error prone to write this everytime you implement bidirectional JSON-RPC.

Because this is such a common use case, we have an API called `JsonRpcServerAndClient` for this purpose, so we recommend using it.

```scala
val serverAndClient = JsonRpcServerAndClient(jsonRpcServer, jsonRpcClient)
serverAndClient.receive(json)
```

`jsonRpcServerAndClient.receive` makes sure to:

- handle the given JSON using the client first then the server second.
- send the response if present using the client's `send` method.

## Shared

We define the following APIs for this example:

```scala
// Server side
trait ClientIdFactoryApi {
  def create(): Future[String]
}

trait RandomNumberSubjectApi {
  def register(clientId: String): Unit

  def unregister(clientId: String): Unit
}

// Client side
trait ClientApi {
  def id: Future[String]
}

trait RandomNumberObserverApi {
  def notify(randomNumber: Int): Unit
}
```

## Scala JS (browser)

Here are our API implementations:

```scala
class ClientApiImpl(promisedId: Promise[String]) extends ClientApi {
  def id: Future[String] = {
    // Client ID needs to be promised because it is generated by server.
    promisedId.future
  }
}

class RandomNumberObserverApiImpl extends RandomNumberObserverApi {
  override def notify(randomNumber: Int): Unit = {
    // Every time we receive random number from server, we just log it.
    println(randomNumber)
  }
}
```

Here is how client communicates with server:

```scala
object Main extends JSApp {
  override def main(): Unit = {
    val webSocket = new dom.WebSocket("ws://localhost:8080/jsonrpc")

    val jsonRpcServerAndClient = createJsonRpcServerAndClient(webSocket)

    webSocket.onmessage = (messageEvent: dom.MessageEvent) => {
      val message = messageEvent.data.toString
      jsonRpcServerAndClient.receive(message)
    }

    val promisedClientId: Promise[String] = Promise()
    jsonRpcServerAndClient.bindApi[ClientApi](new ClientApiImpl(promisedClientId))
    jsonRpcServerAndClient.bindApi[RandomNumberObserverApi](new RandomNumberObserverApiImpl)

    webSocket.onopen = (_: dom.Event) => {
      val clientIdFactoryApi = jsonRpcServerAndClient.createApi[ClientIdFactoryApi]
      val futureClientId: Future[String] = clientIdFactoryApi.create() // Wait until connection is open to use client APIs

      val subjectApi = jsonRpcServerAndClient.createApi[RandomNumberSubjectApi]

      futureClientId.onComplete {
        case Success(id) => {
          promisedClientId.success(id)
          subjectApi.register(id)
        }
        case _ =>
      }
    }
  }

  private def createJsonRpcServerAndClient(webSocket: WebSocket): JsonRpcServerAndClient[UpickleJsonSerializer] = {
    val jsonSerializer = UpickleJsonSerializer()

    val jsonRpcServer = JsonRpcServer(jsonSerializer)

    val jsonSender: (String) => Future[Option[String]] = (json: String) => {
      Try(webSocket.send(json)).fold(
        throwable => Future.failed(throwable),
        _ => Future(None)
      )
    }
    val jsonRpcClient = JsonRpcClient(jsonSerializer, jsonSender)

    JsonRpcServerAndClient(jsonRpcServer, jsonRpcClient)
  }
}
```

## Server

Here are our API implementations:

```scala
class ClientIdFactoryApiImpl extends ClientIdFactoryApi {
  override def create(): Future[String] = {
    val clientId = UUID.randomUUID().toString
    Future(clientId)
  }
}

class RandomNumberSubject(
    observerApiRepository: RandomNumberObserverApiRepository
) extends RandomNumberSubjectApi {
  private var registeredClientIds: Set[String] = Set()

  def start(): Unit = {
    // Once started, it will generate and notify random numbers to registered observers every second.
    val threadPoolExecutor = new ScheduledThreadPoolExecutor(1)
    val executor = new Runnable {
      override def run() = {
        val randomNumber = (Math.random() * 100.0).toInt
        notifyObservers(randomNumber)
      }
    }
    threadPoolExecutor.scheduleAtFixedRate(executor, 1, 1, TimeUnit.SECONDS)
  }

  private def notifyObservers(randomNumber: Int): Unit = {
    val registeredObserverApis = observerApiRepository.getIdToApiMap
        .filterKeys(clientId => registeredClientIds.contains(clientId))
        .values
    registeredObserverApis.foreach(api => api.notify(randomNumber))
  }

  override def register(clientId: String): Unit = {
    println(s"Registering observer with client ID $clientId")
    this.synchronized(registeredClientIds = registeredClientIds + clientId)
  }

  override def unregister(clientId: String): Unit = {
    println(s"Unregistering observer with client ID $clientId")
    this.synchronized(registeredClientIds = registeredClientIds - clientId)
  }
}
```

Here is our WebSocket implementation:

```scala
class JsonRpcWebSocket extends WebSocketAdapter {
  private var serverAndClient: JsonRpcServerAndClient[UpickleJsonSerializer] = _
  private var clientApi: ClientApi = _
  private var observerApi: RandomNumberObserverApi = _

  private val randomNumberSubject = JsonRpcModule.randomNumberSubject
  private val observerApiRepository = JsonRpcModule.randomNumberObserverApiRepository

  override def onWebSocketConnect(session: Session): Unit = {
    super.onWebSocketConnect(session)

    val remote: RemoteEndpoint = session.getRemote
    val jsonSender: (String) => Future[Option[String]] = (json: String) => {
      Try(remote.sendString(json)).fold(
        throwable => Future.failed(throwable),
        _ => Future(None)
      )
    }

    // Create an independent client for each WebSocket session.
    val client = JsonRpcClient(UpickleJsonSerializer(), jsonSender)

    serverAndClient = JsonRpcServerAndClient(JsonRpcModule.jsonRpcServer, client)
    clientApi = serverAndClient.createApi[ClientApi]
    observerApi = serverAndClient.createApi[RandomNumberObserverApi]

    clientApi.id.onComplete {
      case Success(id) => observerApiRepository.add(id, observerApi)
      case _ =>
    }
  }

  override def onWebSocketClose(statusCode: Int, reason: String): Unit = {
    // Automatically unregister the observer on WebSocket close.
    val maybeObserverId: Option[String] = observerApiRepository.remove(observerApi)
    maybeObserverId.foreach(id => randomNumberSubject.unregister(id))

    observerApi = null
    clientApi = null
    serverAndClient = null

    super.onWebSocketClose(statusCode, reason)
  }

  override def onWebSocketText(message: String): Unit = {
    serverAndClient.receive(message)
  }
}
```
